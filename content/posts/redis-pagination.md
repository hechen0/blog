---
title: "Redis Pagination"
date: 2018-04-15T10:19:05+08:00
draft: true
---

# 问题
分页是web应用中非常常见的需求，分页结果来自数据库查询，如何对这个分页结果进行缓存呢？

## 方案一
最简单的方式是按照查询的sql作为缓存key(如将语句 "select * from comments limit 10 offset 0" md5)，结果作为value，如果同样的sql查询发生了，我们就可以命中缓存

## 方案二
redis的list数据结构也可以按需进行分页，将一类记录(如一篇博文下的所有评论)按照需要的顺序LPUSH到一个key下(如blog:2)，使用list的命令LRANGE blog:2 0 10，可以做到对查询直接进行分页

## 方案三
redis的zset，将一类记录放在zset中，使用zset的命令zrangebyscore也可以做到分页

## 方案四
看到[网上有人说](https://www.morpheusdata.com/blog/2016-03-25-the-good-the-bad-and-the-ugly-among-redis-pagination-strategies)可以使用redis的scan(增量遍历)来做分页，这个问题比较多，后面会说。

我们说说前三种方案，前三种方案都是可行的，但都有各自的问题，下面我们结合具体的场景说说前三种方案的具体优劣，最后我会从我的角度解释下为什么方案四不是一种可行的解决方案。

# 场景

以下所列举的所有场景均是我个人的一些偏见，欢迎有经验的大佬们指出其中的问题。

## 场景一 新闻门户首页(腾讯、网易、新浪)

新闻门户

## 场景二 feed流(微博、微信朋友圈、知乎、今日头条)

## 场景三 评论系统(Hacker News、微博评论)



# redis的scan

redis的scan是一种增量遍历(incrementally iterate)，什么叫增量遍历呢?

## scan能做到:

* 从完整遍历开始到完整遍历结束期间，一直存在于键值中的所有元素都会被返回；换而言之，如果有一个元素在整个遍历期间都存在于被遍历的数据集中，那么scan肯定会返回这个元素
* 如果在整个遍历期间，一个元素没有出现在数据集中，那么遍历返回的结果中将不包含这个元素

## scan的缺陷:

* 同一个元素可能会被返回多次，重复的元素需要应用层面处理
* 如果一个元素在scan的过程中被添加或者被删除，那么这个元素可能会被返回，可能不会，行为未定义

## scan返回的元素数量

不保证每次执行都返回某个给定数量的元素，甚至可能会返回0个元素，但只要命令返回的游标不为0，那么遍历就没有结束。
